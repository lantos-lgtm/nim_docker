#
# Docker Engine API
# 
# The Engine API is an HTTP API served by Docker Engine. It is the API the Docker client uses to communicate with the Engine, so everything the Docker client can do can be done with the API.  Most of the client's commands map directly to API endpoints (e.g. `docker ps` is `GET /containers/json`). The notable exception is running containers, which consists of several API calls.  # Errors  The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:  ``` {   \"message\": \"page not found\" } ```  # Versioning  The API is usually changed in each release, so API calls are versioned to ensure that clients don't break. To lock to a specific version of the API, you prefix the URL with its version, for example, call `/v1.30/info` to use the v1.30 version of the `/info` endpoint. If the API version specified in the URL is not supported by the daemon, a HTTP `400 Bad Request` error message is returned.  If you omit the version-prefix, the current version of the API (v1.41) is used. For example, calling `/info` is the same as calling `/v1.41/info`. Using the API without a version-prefix is deprecated and will be removed in a future release.  Engine releases in the near future should support this version of the API, so your client will continue to work even if it is talking to a newer Engine.  The API uses an open schema model, which means server may add extra properties to responses. Likewise, the server will ignore any extra query parameters and request body properties. When you write clients, you need to ignore additional properties in responses to ensure they do not break when talking to newer daemons.   # Authentication  Authentication for registries is handled client side. The client has to send authentication details to various endpoints that need to communicate with registries, such as `POST /images/(name)/push`. These are sent as `X-Registry-Auth` header as a [base64url encoded](https://tools.ietf.org/html/rfc4648#section-5) (JSON) string with the following structure:  ``` {   \"username\": \"string\",   \"password\": \"string\",   \"email\": \"string\",   \"serveraddress\": \"string\" } ```  The `serveraddress` is a domain/IP without a protocol. Throughout this structure, double quotes are required.  If you have already got an identity token from the [`/auth` endpoint](#operation/SystemAuth), you can just pass this instead of credentials:  ``` {   \"identitytoken\": \"9cbaf023786cd7...\" } ``` 
# The version of the OpenAPI document: 1.41
# 
# Generated by: https://openapi-generator.tech
#

# import httpclient
import jsony
import ../utils
import options
import strformat
import strutils
import tables
import typetraits
import uri
import asyncdispatch
import ../customHttpClient
import ../newDockerClient

import ../models/model_container_change_response_item
import ../models/model_container_create_response
import ../models/model_container_create_request
import ../models/model_container_inspect_response
import ../models/model_container_prune_response
import ../models/model_container_summary
import ../models/model_container_stats
import ../models/model_container_top_response
import ../models/model_container_update_response
import ../models/model_container_update_request
import ../models/model_container_wait_response


proc containerArchive*(docker: Docker | AsyncDocker, id: string,
    path: string): Future[void] {.multiSync.} =
  ## Get an archive of a filesystem resource in a container
  var queryForApiCallarray: seq[(string, string)] = @[]
  queryForApiCallarray.addEncode("path",
      path) # Resource in the container’s filesystem to archive.
  let queryForApiCall = queryForApiCallarray.encodeQuery()

  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}/archive"
  uri.query = queryForApiCall
  var response = await docker.client.fetch(uri, HttpMethod.HttpGet,
      headers = docker.headers)
  await response.raiseHttpError()

proc containerArchiveInfo*(docker: Docker | AsyncDocker, id: string,
    path: string): Future[void] {.multiSync.} =
  ## Get information about files in a container
  var queryForApiCallarray: seq[(string, string)] = @[]
  queryForApiCallarray.addEncode("path",
      path) # Resource in the container’s filesystem to archive.
  let queryForApiCall = queryForApiCallarray.encodeQuery()

  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}/archive"
  uri.query = queryForApiCall
  var response = await docker.client.fetch(uri, HttpMethod.HttpHead,
      headers = docker.headers)
  await response.raiseHttpError()


proc containerAttach*(docker: Docker | AsyncDocker, id: string,
    detachKeys: string, logs: bool, stream: bool, stdin: bool, stdout: bool,
    stderr: bool): Future[Response | AsyncResponse] {.multiSync.} =
  ## Attach to a container
  var queryForApiCallarray: seq[(string, string)] = @[]
  queryForApiCallarray.addEncode("detachKeys",
      detachKeys) # Override the key sequence for detaching a container.Format is a single character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`, `@`, `^`, `[`, `,` or `_`.
  queryForApiCallarray.addEncode("logs",
      logs) # Replay previous logs from the container.  This is useful for attaching to a container that has started and you want to output everything since the container started.  If `stream` is also enabled, once all the previous output has been returned, it will seamlessly transition into streaming current output.
  queryForApiCallarray.addEncode("stream",
      stream) # Stream attached streams from the time the request was made onwards.
  queryForApiCallarray.addEncode("stdin", stdin) # Attach to `stdin`
  queryForApiCallarray.addEncode("stdout", stdout) # Attach to `stdout`
  queryForApiCallarray.addEncode("stderr", stderr) # Attach to `stderr`
  let queryForApiCall = queryForApiCallarray.encodeQuery()

  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}/attach"
  uri.query = queryForApiCall
  var response = await docker.client.fetch(uri, HttpMethod.HttpPost,
      headers = docker.headers)
  await response.raiseHttpError()
  return response


proc containerAttachWebsocket*(docker: Docker | AsyncDocker, id: string,
    detachKeys: string, logs: bool, stream: bool): Future[Response |
    AsyncResponse] {.multiSync.} =
  ## Attach to a container via a websocket
  var queryForApiCallarray: seq[(string, string)] = @[]
  queryForApiCallarray.addEncode("detachKeys",
      detachKeys) # Override the key sequence for detaching a container.Format is a single character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`, `@`, `^`, `[`, `,`, or `_`.
  queryForApiCallarray.addEncode("logs", logs) # Return logs
  queryForApiCallarray.addEncode("stream", stream) # Return stream
  let queryForApiCall = queryForApiCallarray.encodeQuery()
  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}/attach/ws"
  uri.query = queryForApiCall
  var response = await docker.client.fetch(uri, HttpMethod.HttpGet,
      headers = docker.headers)
  await response.raiseHttpError()
  return response



proc containerChanges*(docker: Docker | AsyncDocker, id: string): Future[seq[
    ContainerChangeResponseItem]] {.multiSync.} =
  ## Get changes on a container’s filesystem
  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}/changes"
  var response = await docker.client.fetch(uri, HttpMethod.HttpGet,
      headers = docker.headers)
  await response.raiseHttpError()
  let data = await response.body()
  return data.fromJson(result.type)



proc containerCreate*(docker: Docker | AsyncDocker,
    body: ContainerCreateRequest, name: string): Future[
    ContainerCreateResponse] {.multiSync.} =
  ## Create a container
  var queryForApiCallarray: seq[(string, string)] = @[]
  queryForApiCallarray.addEncode("name",
      name) # Assign the specified name to the container. Must match `/?[a-zA-Z0-9][a-zA-Z0-9_.-]+`.
  let queryForApiCall = queryForApiCallarray.encodeQuery()

  var uri = docker.baseUri
  uri.path = "/containers/create"
  uri.query = queryForApiCall
  var response = await docker.client.fetch(uri, HttpMethod.HttpPost,
      body.toJson(), headers = docker.headers)
#   await response.raiseHttpError()
#   let data = await response.body()
#   return data.fromJson(result.type)

proc containerDelete*(docker: Docker | AsyncDocker, id: string, v: bool,
    force: bool, link: bool): Future[void] {.multiSync.} =
  ## Remove a container
  var queryForApiCallarray: seq[(string, string)] = @[]
  queryForApiCallarray.addEncode("v", v) # Remove anonymous volumes associated with the container.
  queryForApiCallarray.addEncode("force",
      force) # If the container is running, kill it before removing it.
  queryForApiCallarray.addEncode("link",
      link) # Remove the specified link associated with the container.
  let queryForApiCall = queryForApiCallarray.encodeQuery()

  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}"
  uri.query = queryForApiCall
  var response = await docker.client.fetch(uri, HttpMethod.HttpDelete,
      headers = docker.headers)
  await response.raiseHttpError()



proc containerExport*(docker: Docker | AsyncDocker, id: string): Future[
    void] {.multiSync.} =
  ## Export a container
  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}/export"
  var response = await docker.client.fetch(uri, HttpMethod.HttpGet,
      headers = docker.headers)
  await response.raiseHttpError()

proc containerInspect*(docker: Docker | AsyncDocker, id: string,
    size: bool): Future[ContainerInspectResponse] {.multiSync.} =
  ## Inspect a container
  var queryForApiCallarray: seq[(string, string)] = @[]
  queryForApiCallarray.addEncode("size",
      size) # Return the size of container as fields `SizeRw` and `SizeRootFs`
  let queryForApiCall = queryForApiCallarray.encodeQuery()

  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}/json"
  uri.query = queryForApiCall
  var response = await docker.client.fetch(uri, HttpMethod.HttpGet,
      headers = docker.headers)
  await response.raiseHttpError()
  let data = await response.body()
  return data.fromJson(result.type)




proc containerKill*(docker: Docker | AsyncDocker, id: string,
    signal: string): Future[void] {.multiSync.} =
  ## Kill a container
  var queryForApiCallarray: seq[(string, string)] = @[]
  queryForApiCallarray.addEncode("signal",
      signal) # Signal to send to the container as an integer or string (e.g. `SIGINT`)
  let queryForApiCall = queryForApiCallarray.encodeQuery()

  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}/kill"
  uri.query = queryForApiCall
  var response = await docker.client.fetch(uri, HttpMethod.HttpPost,
      headers = docker.headers)
  await response.raiseHttpError()

proc containerList*(
  docker: Docker | AsyncDocker,
  all: bool = false,
  limit: Option[int] = none(int),
  size: bool = false,
  filters: Option[Table[string, seq[string]]] = none(Table[string, seq[string]])
): Future[seq[ContainerSummary]] {.multisync.} =
# ): Future[seq[ContainerSummary]] {.async.} =

  var queryForApiCallarray: seq[(string, string)] = @[]
  queryForApiCallarray.addEncode("all", all) # Return all containers. By default, only running containers are shown.
  queryForApiCallarray.addEncode("limit",
      limit) # Return this number of most recently created containers, including non-running ones.
  queryForApiCallarray.addEncode("size",
      size) # Return the size of container as fields `SizeRw` and `SizeRootFs`.
  queryForApiCallarray.addEncode("filters",
      filters) # Filters to process on the container list, encoded as JSON (a `map[string][]string`). For example, `{\"status\": [\"paused\"]}` will only return paused containers.  Available filters:  - `ancestor`=(`<image-name>[:<tag>]`, `<image id>`, or `<image@digest>`) - `before`=(`<container id>` or `<container name>`) - `expose`=(`<port>[/<proto>]`|`<startport-endport>/[<proto>]`) - `exited=<int>` containers with exit code of `<int>` - `health`=(`starting`|`healthy`|`unhealthy`|`none`) - `id=<ID>` a container's ID - `isolation=`(`default`|`process`|`hyperv`) (Windows daemon only) - `is-task=`(`true`|`false`) - `label=key` or `label=\"key=value\"` of a container label - `name=<name>` a container's name - `network`=(`<network id>` or `<network name>`) - `publish`=(`<port>[/<proto>]`|`<startport-endport>/[<proto>]`) - `since`=(`<container id>` or `<container name>`) - `status=`(`created`|`restarting`|`running`|`removing`|`paused`|`exited`|`dead`) - `volume`=(`<volume name>` or `<mount point destination>`)
  let queryForApiCall = queryForApiCallarray.encodeQuery()

  var uri = docker.baseUri
  uri.path = "/containers/json"
  uri.query = queryForApiCall
  var response = await docker.client.fetch(uri, HttpMethod.HttpGet,
      headers = docker.headers)
  await response.raiseHttpError()
  let data = await response.body()
  return data.fromJson(result.type)

proc containerLogs*(docker: Docker | AsyncDocker, id: string, follow: bool,
    stdout: bool, stderr: bool, since: int, until: int, timestamps: bool,
    tail: string): Future[string] {.multiSync.} =
  ## Get container logs

  var queryForApiCallarray: seq[(string, string)] = @[]
  queryForApiCallarray.addEncode("follow", follow) # Keep connection after returning logs.
  queryForApiCallarray.addEncode("stdout", stdout) # Return logs from `stdout`
  queryForApiCallarray.addEncode("stderr", stderr) # Return logs from `stderr`
  queryForApiCallarray.addEncode("since",
      since) # Only return logs since this time, as a UNIX timestamp
  queryForApiCallarray.addEncode("until",
      until) # Only return logs before this time, as a UNIX timestamp
  queryForApiCallarray.addEncode("timestamps", timestamps) # Add timestamps to every log line
  queryForApiCallarray.addEncode("tail",
      tail) # Only return this number of log lines from the end of the logs. Specify as an integer or `all` to output all log lines.
  let queryForApiCall = queryForApiCallarray.encodeQuery()

  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}/logs"
  uri.query = queryForApiCall
  var response = await docker.client.fetch(uri, HttpMethod.HttpGet,
      headers = docker.headers)
  await response.raiseHttpError()
  let data = await response.body()
  return data



proc containerPause*(docker: Docker | AsyncDocker, id: string): Future[
    void] {.multiSync.} =
  ## Pause a container
  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}/pause"
  var response = await docker.client.fetch(uri, HttpMethod.HttpPost,
      headers = docker.headers)
  await response.raiseHttpError()


proc containerPrune*(docker: Docker | AsyncDocker, filters: string): Future[
    ContainerPruneResponse] {.multiSync.} =
  ## Delete stopped containers
  var queryForApiCallarray: seq[(string, string)] = @[]
  queryForApiCallarray.addEncode("filters",
      filters) # Filters to process on the prune list, encoded as JSON (a `map[string][]string`).  Available filters: - `until=<timestamp>` Prune containers created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time. - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune containers with (or without, in case `label!=...` is used) the specified labels.
  let queryForApiCall = queryForApiCallarray.encodeQuery()

  var uri = docker.baseUri
  uri.path = "/containers/prune"
  uri.query = queryForApiCall
  var response = await docker.client.fetch(uri, HttpMethod.HttpPost,
      headers = docker.headers)
  await response.raiseHttpError()
  let data = await response.body()
  return data.fromJson(result.type)



proc containerRename*(docker: Docker | AsyncDocker, id: string,
    name: string): Future[void] {.multiSync.} =
  ## Rename a container
  var queryForApiCallarray: seq[(string, string)] = @[]
  queryForApiCallarray.addEncode("name", name) # New name for the container
  let queryForApiCall = queryForApiCallarray.encodeQuery()

  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}/rename"
  uri.query = queryForApiCall
  var response = await docker.client.fetch(uri, HttpMethod.HttpPost,
      headers = docker.headers)
  await response.raiseHttpError()



proc containerResize*(docker: Docker | AsyncDocker, id: string, h: int,
    w: int): Future[void] {.multiSync.} =
  ## Resize a container TTY
  var queryForApiCallarray: seq[(string, string)] = @[]
  queryForApiCallarray.addEncode("h", h) # Height of the TTY session in characters
  queryForApiCallarray.addEncode("w", w) # Width of the TTY session in characters
  let queryForApiCall = queryForApiCallarray.encodeQuery()
  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}/resize"
  uri.query = queryForApiCall
  var response = await docker.client.fetch(uri, HttpMethod.HttpPost,
      headers = docker.headers)
  await response.raiseHttpError()


proc containerRestart*(docker: Docker | AsyncDocker, id: string,
    t: int): Future[void] {.multiSync.} =
  ## Restart a container
  var queryForApiCallarray: seq[(string, string)] = @[]
  queryForApiCallarray.addEncode("t", t) # Number of seconds to wait before killing the container
  let queryForApiCall = queryForApiCallarray.encodeQuery()
  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}/restart"
  uri.query = queryForApiCall
  var response = await docker.client.fetch(uri, HttpMethod.HttpPost,
      headers = docker.headers)
  await response.raiseHttpError()

proc containerStart*(docker: Docker | AsyncDocker, id: string,
    detachKeys: string = ""): Future[void] {.multisync.} =
  ## Start a container
  var queryForApiCallarray: seq[(string, string)] = @[]
  queryForApiCallarray.addEncode("detachKeys",
      detachKeys) # Override the key sequence for detaching a container. Format is a single character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`, `@`, `^`, `[`, `,` or `_`.
  let queryForApiCall = queryForApiCallarray.encodeQuery()
  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}/start"
  uri.query = queryForApiCall
  var response = await docker.client.fetch(uri, HttpMethod.HttpPost,
      headers = docker.headers)
  await response.raiseHttpError()

iterator containerStats*(
    docker: Docker | AsyncDocker,
    id: string,
    stream: bool = true,
    oneShot: bool = false
  ): ContainerStats =

  ## Get container stats based on resource usage
  var queryForApiCallarray: seq[(string, string)] = @[]
  queryForApiCallarray.addEncode("stream",
      stream) # Stream the output. If false, the stats will be output once and then it will disconnect.
  queryForApiCallarray.addEncode("one-shot",
      $oneShot) # Only get a single stat instead of waiting for 2 cycles. Must be used with `stream=false`.
  let queryForApiCall = queryForApiCallarray.encodeQuery()

  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}/stats"
  uri.query = queryForApiCall
  var response = when docker is Docker:
    docker.client.fetch(uri, HttpMethod.HttpGet, headers = docker.headers)
  else:
    waitFor docker.client.fetch(uri, HttpMethod.HttpGet,
        headers = docker.headers)

  when docker is Docker:
    response.raiseHttpError()
  else:
    waitFor response.raiseHttpError()

  for data in response.body():
    yield data.fromJson(ContainerStats)

proc containerStop*(docker: Docker | AsyncDocker, id: string,
    t: int = 0): Future[void] {.multiSync.} =
  ## Stop a container
  var queryForApiCallarray: seq[(string, string)] = @[]
  queryForApiCallarray.addEncode("t", t) # Number of seconds to wait before killing the container
  let queryForApiCall = queryForApiCallarray.encodeQuery()
  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}/stop"
  uri.query = queryForApiCall
  var response = await docker.client.fetch(uri, HttpMethod.HttpPost,
      headers = docker.headers)
  await response.raiseHttpError()


proc containerTop*(docker: Docker | AsyncDocker, id: string,
    psArgs: string): Future[ContainerTopResponse] {.multiSync.} =
  ## List processes running inside a container
  var queryForApiCallarray: seq[(string, string)] = @[]
  queryForApiCallarray.addEncode("ps_args",
      psArgs) # The arguments to pass to `ps`. For example, `aux`
  let queryForApiCall = queryForApiCallarray.encodeQuery()
  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}/top"
  uri.query = queryForApiCall
  var response = await docker.client.fetch(uri, HttpMethod.HttpPost,
      headers = docker.headers)
  await response.raiseHttpError()
  let data = await response.body()
  return data.fromJson(result.type)


proc containerUnpause*(docker: Docker | AsyncDocker, id: string): Future[
    void] {.multiSync.} =
  ## Unpause a container
  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}/tounpausep"
  var response = await docker.client.fetch(uri, HttpMethod.HttpPost,
      headers = docker.headers)
  await response.raiseHttpError()

proc containerUpdate*(docker: Docker | AsyncDocker, id: string,
    update: ContainerUpdateRequest): Future[
    ContainerUpdateResponse] {.multiSync.} =
  ## Update a container
  docker.headers["Content-Type"] = "application/json"
  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}/update"
  var response = await docker.client.fetch(uri, HttpMethod.HttpPost,
      update.toJson(), headers = docker.headers)
  await response.raiseHttpError()
  let data = await response.body()
  return data.fromJson(result.type)

proc containerWait*(docker: Docker | AsyncDocker, id: string,
    condition: string): Future[ContainerWaitResponse] {.multiSync.} =
  ## Wait for a container
  var queryForApiCallarray: seq[(string, string)] = @[]
  queryForApiCallarray.addEncode("condition",
      condition) # Wait until a container state reaches the given condition.  Defaults to `not-running` if omitted or empty.
  let queryForApiCall = queryForApiCallarray.encodeQuery()

  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}/wait"
  uri.query = queryForApiCall
  var response = await docker.client.fetch(uri, HttpMethod.HttpPost,
      headers = docker.headers)
  await response.raiseHttpError()
  let data = await response.body()
  return data.fromJson(result.type)


proc putContainerArchive*(docker: Docker | AsyncDocker, id: string,
    path: string, inputStream: string, noOverwriteDirNonDir: string,
    copyUIDGID: string): Future[void] {.multiSync.} =
  ## Extract an archive of files or folders to a directory in a container
  docker.headers["Content-Type"] = "application/json"
  var queryForApiCallarray: seq[(string, string)] = @[]
  queryForApiCallarray.addEncode("path",
      path) # Path to a directory in the container to extract the archive’s contents into.
  queryForApiCallarray.addEncode("noOverwriteDirNonDir",
      noOverwriteDirNonDir) # If `1`, `true`, or `True` then it will be an error if unpacking the given content would cause an existing directory to be replaced with a non-directory and vice versa.
  queryForApiCallarray.addEncode("copyUIDGID",
      copyUIDGID) # If `1`, `true`, then it will copy UID/GID maps to the dest file or dir
  let queryForApiCall = queryForApiCallarray.encodeQuery()
  var uri = docker.baseUri
  uri.path = fmt"/containers/{id}/archive"
  uri.query = queryForApiCall
  var response = await docker.client.fetch(uri, HttpMethod.HttpPut,
      inputStream.toJson(), headers = docker.headers)
  await response.raiseHttpError()
